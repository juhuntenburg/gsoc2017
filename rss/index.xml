<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Integrating CBS Tools in the Nipy community]]></title><description><![CDATA[My development blog for the Google Summer of Code 2017]]></description><link>https://juhuntenburg.github.io/gsoc2017</link><image><url>http://github.com/juhuntenburg/gsoc2017/blob/gh-pages/images/blog_cover.png</url><title>Integrating CBS Tools in the Nipy community</title><link>https://juhuntenburg.github.io/gsoc2017</link></image><generator>RSS for Node</generator><lastBuildDate>Thu, 27 Jul 2017 18:09:41 GMT</lastBuildDate><atom:link href="https://juhuntenburg.github.io/gsoc2017/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Github project management]]></title><description><![CDATA[<div class="paragraph">
<p>Following a workshop at Brainhack Vancouver by the amazing <a href="https://twitter.com/kirstie_j">@kirstie_j</a>, I started organizing my GSoC work using <a href="https://help.github.com/articles/tracking-the-progress-of-your-work-with-project-boards/">github project boards</a>. I probably use it a bit differently than intended&#8201;&#8212;&#8201;mostly to keep track of my own tasks and asking questions to my mentors&#8201;&#8212;&#8201;but find it extremely useful. We still have more detailed or organizational discussions on slack, but the project board is great to keep an overview without yet another tool (such as Trello &amp; Co.)</p>
</div>]]></description><link>https://juhuntenburg.github.io/gsoc2017/2017/07/21/Github-project-management.html</link><guid isPermaLink="true">https://juhuntenburg.github.io/gsoc2017/2017/07/21/Github-project-management.html</guid><dc:creator><![CDATA[Julia Huntenburg]]></dc:creator><pubDate>Fri, 21 Jul 2017 00:00:00 GMT</pubDate></item><item><title><![CDATA[A documentation for documentation]]></title><description><![CDATA[<div class="paragraph">
<p>These days I am writing the Python interfaces to the JCC-wrapped Java code, that will eventually be exposed to the user. This also means writing comprehensive docstrings. Up until now I mostly freestyled docstrings, roughly trying to imitate what I had seen (and liked) in other packages, or other functions of the package I worked on. But searching for something docstring-related I stumbled upon the <a href="https://www.python.org/dev/peps/pep-0257/">PEP257 docstring conventions</a>. Maybe not so surprising that they exist. More surprising, there are specific <a href="https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt#docstring-standard">NumPy/SciPy docstring conventions</a> (and <a href="http://sphinxcontrib-napoleon.readthedocs.io/en/latest/example_numpy.html">examples</a>). It makes sense for us to follow the Scientific Python community convenstions, and so far I find the style clean, easy to follow and flexible enough for package specifics. Plus the warm and fuzzy feeling of following standards (#GermanAfterAll). Hooray!</p>
</div>]]></description><link>https://juhuntenburg.github.io/gsoc2017/2017/07/18/A-documentation-for-documentation.html</link><guid isPermaLink="true">https://juhuntenburg.github.io/gsoc2017/2017/07/18/A-documentation-for-documentation.html</guid><dc:creator><![CDATA[Julia Huntenburg]]></dc:creator><pubDate>Tue, 18 Jul 2017 00:00:00 GMT</pubDate></item><item><title><![CDATA[Brainhack Vancouver]]></title><description><![CDATA[<div class="paragraph">
<p>From June 22-24 I was at the <a href="https://ohbm.github.io/hackathon2017/">OHBM Hackathon 2017</a> in Vancouver and <a href="https://docs.google.com/presentation/d/1OG7BWQRG93nNkFRYnfPNnj7AoosHUQwAdbQgAAq78i8/edit?usp=sharing">pitched</a> a project to implement the distribution for cbstools-python. I mostly hoped that some of the folks there had some advice, but did not really expect anyone to get overly excited about joining this pretty specific project. Turns out I still underestimate the power of <a href="http://www.brainhack.org/about.html">brainhack</a>&#8201;&#8212;&#8201;right after the pitch <a href="https://github.com/kofalt">kofalt</a> came up to me and said he would love to join.</p>
</div>
<div class="paragraph">
<p>Within two &amp; 1/2 intense and fun days we managed to pool his expertise on software packaging and distribution, my recently acquired knowledge about PyPI and what we want for cbstools-python, and some helpful insights from other brainhackers into a single, but powerful <a href="https://github.com/kofalt/cbstools-public/blob/master/build.sh">script</a>. It performs the following essential steps:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Download the MIPAV and JIST dependencies (should become redundant soon)</p>
</li>
<li>
<p>Compile the Java code</p>
</li>
<li>
<p>Wrap the Java classes using JCC</p>
</li>
<li>
<p>Build the right folder structure and finally a wheel</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This automates all steps necessary for continuous integration and distribution via PyPI. It will need to be adapted once the high-level Python interfaces have been added and we have decided on the final code organization. Also a few small issues regarding continuous integration are still to be solved. But it is still a <em>massive step forward</em> and much more than I ever expected to get done in that short time.</p>
</div>
<div class="paragraph">
<p>As usual, I left brainhack tired but thrilled: about this awesome, inspiring community, and about having learned more in a few days than in a regular month or more back at university. If you are into neuroscience and coding, you should definitely check out the next brainhack in your region, or just organize one yourself.</p>
</div>]]></description><link>https://juhuntenburg.github.io/gsoc2017/2017/07/16/Brainhack-Vancouver.html</link><guid isPermaLink="true">https://juhuntenburg.github.io/gsoc2017/2017/07/16/Brainhack-Vancouver.html</guid><dc:creator><![CDATA[Julia Huntenburg]]></dc:creator><pubDate>Sun, 16 Jul 2017 00:00:00 GMT</pubDate></item><item><title><![CDATA[Distributing]]></title><description><![CDATA[<div class="paragraph">
<p>Recently I tried to learn about <a href="https://python-packaging-user-guide.readthedocs.io/tutorials/distributing-packages/">distributing Python packages through PyPI</a>. While that seems more or less straightforward for pure Python projects, the story gets more complicated for our case, where extensions in another language need to be compiled in a platform-dependent manner. I ended up with some insights, but also a lot of remaining confusion:</p>
</div>
<div class="olist arabic">
<div class="title">Generally there are two options:</div>
<ol class="arabic">
<li>
<p>compiling the extensions during installation</p>
</li>
<li>
<p>distributing pre-compiled binaries</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>For 1. I found very little information on how to actually implement that. One option seems to <a href="https://docs.python.org/2/extending/building.html">build the extensions using distutils</a> in the setup.py script, although I am not sure if that requires the user to install from source, instead of installing using pip. One <a href="https://stackoverflow.com/questions/31380578/how-to-avoid-building-c-library-with-my-python-package">post</a> mentions that they used <code>build_ext</code> with pip to build a C extension during installation, but I could just not find any information on how exactly that works.</p>
</div>
<div class="paragraph">
<p>I found much more information on option 2. The preferred way to package binary extensions through are <a href="https://python-packaging-user-guide.readthedocs.io/tutorials/distributing-packages/#wheels">wheels</a>.
&gt;A wheel is a built package that can be installed without needing to go through the build process. Installing wheels is substantially faster for the end user than installing from a source distribution.</p>
</div>
<div class="paragraph">
<p>In our case we would need to create a Platform Wheel, which is a platform dependent wheel that contains compiled extensions. PyPI currently supports wheels for Windows and OS X but only a compatible <a href="https://www.python.org/dev/peps/pep-0513/">subset of linux distributions</a>. Wheels appear to be the preferred and more standardized way of packaging versus the older egg format (see this <a href="https://packaging.python.org/discussions/wheel-vs-egg/">discussion</a>) and are used e.g. to manage <a href="https://pypi.python.org/pypi/numpy">Numpy</a> distribution.</p>
</div>
<div class="paragraph">
<div class="title">Conda</div>
<p>Another option is to use conda to package our project. This is where I am still confused. Building a <a href="https://conda.io/docs/build_tutorials/pkgs.html">conda package from an existing PyPI project</a> seems straightforward. Those can apparently be build for one platfrom, converted for others and then uploaded to anaconda.org. But I am not sure if that is only true for Python packages, or for binary extensions too, and how it works in the latter case (do the extensions already have to be on PyPI?). There is also a tutorial how to build a <a href="https://conda.io/docs/build_tutorials/postgis.html">conda package from scratch for any language</a>, for which no PyPI project is required. But it is still a bit obscure to me how exactly that works, and what are the advantages over using PyPI with wheels. I found some thoughts on the latter question <a href="https://jakevdp.github.io/blog/2016/08/25/conda-myths-and-misconceptions/">here under Myth#6</a></p>
</div>
<div class="paragraph">
<p>Hopefully I can update with a better understanding soon.</p>
</div>]]></description><link>https://juhuntenburg.github.io/gsoc2017/2017/06/16/Distributing.html</link><guid isPermaLink="true">https://juhuntenburg.github.io/gsoc2017/2017/06/16/Distributing.html</guid><dc:creator><![CDATA[Julia Huntenburg]]></dc:creator><pubDate>Fri, 16 Jun 2017 00:00:00 GMT</pubDate></item><item><title><![CDATA[To Docker or not to Docker]]></title><description><![CDATA[<div class="paragraph">
<p>Reaching out to the neuroimaging community regarding means of software distribution got me many helpful replies and I learned quite a bit about Docker and related tools along the way. My main take-aways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Docker as a scientific tool in the neuroimaging community is of growing importance, as exemplified by <a href="http://bids-apps.neuroimaging.io/">BIDS Apps</a> or <a href="http://natacha-beck.github.io/cbrain_docker/#/">CBRAIN</a>. However, it still in an early stage so that widespread adoption will take time and installation procedures might need to be tweaked due to changes to the Docker project itself.</p>
</li>
<li>
<p>Default Docker images such as AlpineLinux do not add a lot of overhead (they are much smaller than virtual machines) and should not result in a significant performance penalties unless one is dealing with super efficient numerical code.</p>
</li>
<li>
<p>Using Docker in combination with <a href="http://singularity.lbl.gov/">Singularity</a> helps to run containers without root access and without Docker being actually installed, e.g. on HPCs</p>
</li>
<li>
<p>When distributing through Docker it is even more important to have good regression tests across platforms and software versions. There are two projects trying to make this easier: <a href="https://github.com/kaczmarj/neurodocker">neurodocker</a> and <a href="https://github.com/ReproNim/niceman">niceman</a></p>
</li>
<li>
<p>One interesting approach is, in addition to the Docker image, to publish a <a href="https://github.com/poldracklab/fmriprep/blob/master/wrapper/fmriprep_docker.py">standalone script</a> that generates Docker commands for users through <a href="https://pypi.python.org/pypi/fmriprep-docker">PyPI</a>, so it can be install with pip.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>One of the most helpful comments regarding our project I found to be this (<a href="https://neurostars.org/t/using-docker-to-distribute-highres-neuroimaging-software/442/2?u=juhuntenburg">on neurostars.org</a>):</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>"If you are looking to distribute a library that is intended to be integrated with other software wrapping it in Docker will make it hard if not impossible. If you are looking to distribute a command line tool with complex set of dependencies Docker is a good fit."</p>
</div>
</div>
</div>
<div class="paragraph">
<p>From the replies and talking to my mentors I got the sense that it will be the best choice for us to focus on more traditional ways of download and installation for now. Especially, because integrating our tools with other software is a main objective of this project. But we will also explore if it makes sense to additionally provide a Docker Image later on.</p>
</div>
<div class="paragraph">
<p><em>Thanks for all the helpful comments and suggestions!</em></p>
</div>]]></description><link>https://juhuntenburg.github.io/gsoc2017/2017/06/03/To-Docker-or-not-to-Docker.html</link><guid isPermaLink="true">https://juhuntenburg.github.io/gsoc2017/2017/06/03/To-Docker-or-not-to-Docker.html</guid><dc:creator><![CDATA[Julia Huntenburg]]></dc:creator><pubDate>Sat, 03 Jun 2017 00:00:00 GMT</pubDate></item><item><title><![CDATA[Wisdom of the crowd]]></title><description><![CDATA[<div class="paragraph">
<p>This week, GSoC started with the "community bonding" phase. I already feel pretty bonded with my software community (in fact I constitute 1/3 of it), so I use the time to reach out to the larger neuroimaging community regarding one of the first issues I want to address:</p>
</div>
<div class="paragraph">
<p><em>What is the best way to distribute the Python version of CBS Tools?</em></p>
</div>
<div class="paragraph">
<p>I have previously discussed this question with my mentors and other colleagues, and one suggestion that came up is to deploy the tools via <a href="https://www.docker.com/">Docker</a>. In order to find out what neuroimaging folks think about docker I have started discussion threads on <a href="https://neurostars.org/t/using-docker-to-distribute-highres-neuroimaging-software/442">neurostars</a> and in the <a href="https://brainhack-slack-invite.herokuapp.com/">brainhack slack team</a>.</p>
</div>
<div class="paragraph">
<p>I know very little about docker myself, so I also started watching some <a href="https://www.youtube.com/playlist?list=PLoYCgNOIyGAAzevEST2qm2Xbe3aeLFvLc">tutorials</a>. Whether we end up using it or not, my feeling is it won&#8217;t hurt in the future to know a thing or two about docker.</p>
</div>]]></description><link>https://juhuntenburg.github.io/gsoc2017/2017/05/11/Wisdom-of-the-crowd.html</link><guid isPermaLink="true">https://juhuntenburg.github.io/gsoc2017/2017/05/11/Wisdom-of-the-crowd.html</guid><dc:creator><![CDATA[Julia Huntenburg]]></dc:creator><pubDate>Thu, 11 May 2017 00:00:00 GMT</pubDate></item><item><title><![CDATA[Google Summer of Code (GSoC)]]></title><description><![CDATA[<div class="paragraph">
<p>On this site I will document my work during the Google Summer of Code 2017 with INCF. Follow the links for a project description in <a href="https://summerofcode.withgoogle.com/projects/?sp-page=2#5716469263368192">short</a> or <a href="https://docs.google.com/document/d/1lkcTpcYT1r1qwh4GwccyWjY3cq2VZ89AlQoKa4Fd2aQ/edit?usp=sharing">long</a>.</p>
</div>]]></description><link>https://juhuntenburg.github.io/gsoc2017/2017/05/08/Google-Summer-of-Code-G-SC.html</link><guid isPermaLink="true">https://juhuntenburg.github.io/gsoc2017/2017/05/08/Google-Summer-of-Code-G-SC.html</guid><dc:creator><![CDATA[Julia Huntenburg]]></dc:creator><pubDate>Mon, 08 May 2017 00:00:00 GMT</pubDate></item></channel></rss>